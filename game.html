<!DOCTYPE html>
<html>
<head>
    <title>Cube Runner 3D</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; z-index: 100; font-size: 18px; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; display: none; font-size: 20px; }
        #controls { position: absolute; top: 10px; right: 10px; z-index: 100; }
        button { padding: 15px 25px; margin: 5px; font-size: 18px; cursor: pointer; border: none; border-radius: 5px; }
        #swipeArea { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; }
        #mobileControls { display: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Health: <span id="health">3</span></div>
        <div>Swipe left/right to move</div>
    </div>
    <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Press R to restart</p>
    </div>
    <div id="controls">
        <button id="pauseBtn" onclick="togglePause()">PAUSE</button>
        <button onclick="restartGame()">RESTART</button>
    </div>
    <div id="swipeArea"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let score = 0, health = 3, gameRunning = true, invincible = false, paused = false;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB);
        document.body.appendChild(renderer.domElement);

        // Player - Pixelated Cat (based on reference image)
        const playerGroup = new THREE.Group();
        
        const pixelSize = 0.12;
        const lightGrey = 0xC0C0C0;
        const darkGrey = 0x808080;
        const black = 0x000000;
        const pink = 0xFF69B4;
        const red = 0xFF0000;
        
        // Cat body (lying down position like in image)
        const body = new THREE.Mesh(
            new THREE.BoxGeometry(pixelSize * 5, pixelSize * 2, pixelSize * 3),
            new THREE.MeshBasicMaterial({ color: lightGrey })
        );
        body.position.set(0, pixelSize * 0.5, 0);
        
        // Cat head (attached to body)
        const head = new THREE.Mesh(
            new THREE.BoxGeometry(pixelSize * 3, pixelSize * 2.5, pixelSize * 3),
            new THREE.MeshBasicMaterial({ color: lightGrey })
        );
        head.position.set(pixelSize * 3, pixelSize * 0.8, 0);
        
        // Pointy ears (black outline)
        const ear1 = new THREE.Mesh(
            new THREE.ConeGeometry(pixelSize * 0.8, pixelSize * 1.5, 4),
            new THREE.MeshBasicMaterial({ color: black })
        );
        ear1.position.set(pixelSize * 2.5, pixelSize * 2.5, -pixelSize * 0.8);
        
        const ear2 = new THREE.Mesh(
            new THREE.ConeGeometry(pixelSize * 0.8, pixelSize * 1.5, 4),
            new THREE.MeshBasicMaterial({ color: black })
        );
        ear2.position.set(pixelSize * 3.5, pixelSize * 2.5, -pixelSize * 0.8);
        
        // Inner ears (light grey)
        const innerEar1 = new THREE.Mesh(
            new THREE.ConeGeometry(pixelSize * 0.5, pixelSize * 1, 4),
            new THREE.MeshBasicMaterial({ color: lightGrey })
        );
        innerEar1.position.set(pixelSize * 2.5, pixelSize * 2.3, -pixelSize * 0.8);
        
        const innerEar2 = new THREE.Mesh(
            new THREE.ConeGeometry(pixelSize * 0.5, pixelSize * 1, 4),
            new THREE.MeshBasicMaterial({ color: lightGrey })
        );
        innerEar2.position.set(pixelSize * 3.5, pixelSize * 2.3, -pixelSize * 0.8);
        
        // Eyes (black dots)
        const eye1 = new THREE.Mesh(
            new THREE.BoxGeometry(pixelSize * 0.4, pixelSize * 0.4, pixelSize * 0.4),
            new THREE.MeshBasicMaterial({ color: black })
        );
        eye1.position.set(pixelSize * 4.2, pixelSize * 1.2, pixelSize * 0.6);
        
        const eye2 = new THREE.Mesh(
            new THREE.BoxGeometry(pixelSize * 0.4, pixelSize * 0.4, pixelSize * 0.4),
            new THREE.MeshBasicMaterial({ color: black })
        );
        eye2.position.set(pixelSize * 4.2, pixelSize * 1.2, -pixelSize * 0.6);
        
        // Pink nose
        const nose = new THREE.Mesh(
            new THREE.BoxGeometry(pixelSize * 0.3, pixelSize * 0.2, pixelSize * 0.2),
            new THREE.MeshBasicMaterial({ color: pink })
        );
        nose.position.set(pixelSize * 4.8, pixelSize * 0.8, 0);
        
        // Red mouth/tongue
        const mouth = new THREE.Mesh(
            new THREE.BoxGeometry(pixelSize * 0.2, pixelSize * 0.3, pixelSize * 0.4),
            new THREE.MeshBasicMaterial({ color: red })
        );
        mouth.position.set(pixelSize * 4.6, pixelSize * 0.4, 0);
        
        // Striped pattern on body (dark grey stripes)
        for(let i = 0; i < 3; i++) {
            const stripe = new THREE.Mesh(
                new THREE.BoxGeometry(pixelSize * 0.8, pixelSize * 2.2, pixelSize * 3.2),
                new THREE.MeshBasicMaterial({ color: darkGrey })
            );
            stripe.position.set(-pixelSize * 1.5 + i * pixelSize * 1.5, pixelSize * 0.5, 0);
            playerGroup.add(stripe);
        }
        
        // Curved tail (multiple segments)
        for(let i = 0; i < 6; i++) {
            const tailSegment = new THREE.Mesh(
                new THREE.CylinderGeometry(pixelSize * 0.3, pixelSize * 0.2, pixelSize * 1),
                new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? lightGrey : darkGrey })
            );
            tailSegment.position.set(
                -pixelSize * 3 - i * pixelSize * 0.8,
                pixelSize * 0.5 + Math.sin(i * 0.5) * pixelSize,
                Math.cos(i * 0.3) * pixelSize * 0.5
            );
            tailSegment.rotation.z = i * 0.3;
            playerGroup.add(tailSegment);
        }
        
        // Small paws
        for(let i = 0; i < 4; i++) {
            const paw = new THREE.Mesh(
                new THREE.SphereGeometry(pixelSize * 0.4, 8, 8),
                new THREE.MeshBasicMaterial({ color: lightGrey })
            );
            paw.position.set(
                i < 2 ? pixelSize * 1.5 : -pixelSize * 1.5,
                -pixelSize * 0.3,
                i % 2 === 0 ? pixelSize * 1 : -pixelSize * 1
            );
            playerGroup.add(paw);
        }
        
        playerGroup.add(body, head, ear1, ear2, innerEar1, innerEar2, eye1, eye2, nose, mouth);
        playerGroup.position.y = 0;
        scene.add(playerGroup);
        const player = playerGroup;
        
        // Store body parts for color changes
        const bodyParts = [body, head];

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(20, 50);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1;
        scene.add(ground);

        // Game objects
        const coins = [];
        const enemies = [];
        let playerVelocityY = 0;
        let isGrounded = true;

        // Create coins
        function createCoin() {
            const coinGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1);
            const coinMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.position.set(
                (Math.random() - 0.5) * 8,
                0.5,
                -Math.random() * 20 - 10
            );
            coins.push(coin);
            scene.add(coin);
        }

        // Create enemies
        function createEnemy() {
            const enemyGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.set(
                (Math.random() - 0.5) * 6,
                0.2,
                -Math.random() * 20 - 10
            );
            enemies.push(enemy);
            scene.add(enemy);
        }

        // Initialize game objects
        for (let i = 0; i < 10; i++) {
            createCoin();
            if (i < 5) createEnemy();
        }

        camera.position.set(0, 3, 8);
        camera.lookAt(player.position);

        // Controls (keyboard + touch)
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'KeyR' && !gameRunning) restartGame();
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);
        
        // Simple swipe controls - left/right only
        const mobileKeys = {};
        let touchStartX = 0;
        
        const swipeArea = document.getElementById('swipeArea');
        
        swipeArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
        });
        
        swipeArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touchX = e.touches[0].clientX;
            const deltaX = touchX - touchStartX;
            
            // Reset movement
            mobileKeys['ArrowLeft'] = false;
            mobileKeys['ArrowRight'] = false;
            
            // Swipe left/right (minimum 20px movement)
            if (Math.abs(deltaX) > 20) {
                if (deltaX > 0) mobileKeys['ArrowRight'] = true;
                else mobileKeys['ArrowLeft'] = true;
            }
        });
        
        swipeArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            mobileKeys['ArrowLeft'] = false;
            mobileKeys['ArrowRight'] = false;
        });


        function togglePause() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'START' : 'PAUSE';
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('health').textContent = health;
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            score = 0;
            health = 3;
            gameRunning = true;
            invincible = false;
            player.position.set(0, 0, 0);
            document.getElementById('gameOver').style.display = 'none';
            
            // Reset coins and enemies
            coins.forEach(coin => scene.remove(coin));
            enemies.forEach(enemy => scene.remove(enemy));
            coins.length = 0;
            enemies.length = 0;
            
            for (let i = 0; i < 10; i++) {
                createCoin();
                if (i < 5) createEnemy();
            }
        }

        function checkCollisions() {
            // Coin collection
            coins.forEach((coin, index) => {
                if (player.position.distanceTo(coin.position) < 0.7) {
                    scene.remove(coin);
                    coins.splice(index, 1);
                    score += 10;
                    
                    // Spawn new coin
                    createCoin();
                }
            });

            // Enemy collision
            if (!invincible) {
                enemies.forEach((enemy, index) => {
                    if (player.position.distanceTo(enemy.position) < 1.0) {
                        health--;
                        invincible = true;
                        
                        // Flash player red
                        bodyParts.forEach(part => part.material.color.setHex(0xff0000));
                        setTimeout(() => {
                            bodyParts.forEach(part => part.material.color.setHex(lightGrey));
                            invincible = false;
                        }, 1000);
                        
                        if (health <= 0) gameOver();
                    }
                });
            }
        }

        function animate() {
            if (!gameRunning || paused) {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
                return;
            }

            requestAnimationFrame(animate);

            // Player movement (left/right swipe only)
            const isPressed = (key) => keys[key] || mobileKeys[key];
            
            if (isPressed('ArrowLeft') && player.position.x > -4) player.position.x -= 0.1;
            if (isPressed('ArrowRight') && player.position.x < 4) player.position.x += 0.1;
            
            // Auto-forward movement
            if (player.position.z > -10) player.position.z -= 0.05;

            // Gravity
            player.position.y += playerVelocityY;
            playerVelocityY -= 0.01;
            
            if (player.position.y <= 0) {
                player.position.y = 0;
                playerVelocityY = 0;
                isGrounded = true;
            }

            // Move world towards player
            coins.forEach(coin => {
                coin.position.z += 0.05;
                coin.rotation.y += 0.1;
                if (coin.position.z > 10) {
                    coin.position.z = -20;
                    coin.position.x = (Math.random() - 0.5) * 8;
                }
            });

            enemies.forEach(enemy => {
                enemy.position.z += 0.03;
                enemy.rotation.x += 0.05;
                if (enemy.position.z > 10) {
                    enemy.position.z = -20;
                    enemy.position.x = (Math.random() - 0.5) * 8;
                }
            });

            checkCollisions();
            updateUI();
            
            // Camera follows player
            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 8;
            camera.lookAt(player.position);

            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>